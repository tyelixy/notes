# http协议



### web及网络基础

> web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。
>
> 是建立在Internet上的一种网络服务。

根据 Web 浏览器地址栏中指定的 URL，_Web浏览器从 Web服务器端获取文件资源等信息_，从而显示出 Web 页面。 像这种_通过发送请求获取服务器资源_ 的 Web 浏览器等，都可称为客户端。 

#### http协议（HyperText Transfer Protocol，超文本传输协议）

web使用http协议作为规范，完成从客户端到服务器端等一系列运作流程。

web是建立在http协议上通信的。

##### 诞生

最初设想的基本理念是：借助多文档之间相互关联形成的超文本 （HyperText），连成可相互参阅的 WWW（World Wide Web，万维 网）。 

已提出了 3 项 WWW 构建技术，分别是：

* 把 SGML[^1]作为页面的文本标记语言的HTML[^2]
* 作为文档传递协议的 HTTP
* 指定文档所在地址的 URL（Uniform 12Resource Locator，统一资源定位符）

[^1]: Standard Generalized Markup Language，标准通用标记语言
[^2]: HyperText Markup Language，超文本标记语言

#### TCP/IP 协议族

> 计算机与网络设备要相互通信，双方就必须基于相同的方法。

##### 分层

TCP/IP协议族按层次分别分为以下4 层：应用层、传输层、网络层和数据链路层

###### 应用层

决定了向用户提供应用服务时的通信活动。

###### 传输层

对应用层提供处于网络连接中的两台计算机之间的数据传输。

###### 网络层

处理网络上流动的数据包[^3]。

###### 链路层

用来处理连接网络的硬件部分。

##### 通信传输流

利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。==发送端从应用层往下走，接收端则往应用层往上走。==

***

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该 层所属的首部信息。

反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。

 这种把数据信息包装起来的做法称为__封装（encapsulate）__。

[^3]:数据包，网络传输的最小数据单位

#### IP、TCP、DNS

##### IP协议

> 负责传输，位于网络层

***

###### IP地址

指明了节点被分配到的地址

###### MAC地址

指网卡所属的固定地址

***

IP 地址可以和 MAC 地址进行配对。

IP 地址可变换，但 MAC 地址基本上不会更改。

***

###### 使用 ARP 协议凭借 MAC 地址进行通信

ARP是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。

> ？p21

##### TCP协议

> 位于传输层，提供可靠的字节流服务

###### 字节流服务（Byte Stream Service）

为了方便传输，将大块数据分割成以报文段（segment）[^4]为单位的数据包进行管理。

###### 可靠的传输服务

> 能够把数据准确可靠地传给对方。

TCP 协议采用了三次握手 （three-way handshaking）策略。

握手过程中使用了 TCP 的标志（flag）—— SYN（synchronize）和ACK（acknowledgement）。

> 发送端首先发送一个带 SYN 标志的数据包给对方。
>
> 接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。
>
> 最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束

除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。

[^4]:报文段 ，是指TCP/IP协议网络传输过程中，起着路由导航，查询各个网络路由网段,IP地址，交换协议等IP数据包。报文段充当整个TCP/IP协议数据包的__导航路由功能__。

##### DNS服务

> 负责域名解析
>
> 位于应用层，提供域名到 IP 地址之间的解析服务

计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。

DNS 协议提供__通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。__

#### URI（统一资源标识符）、URL（统一资源定位符）

>  URL是 URI 的子集

##### URI

URI 就是__由某个协议方案表示的资源的定位标识符__。协议方案是指访问资源所使用的协议类型名称。

***

表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL以及相对URL

###### URI格式

![](D:\txy\University\New_Thread\GEEK\笔记\URI格式.PNG)

### 简单的HTTP协议

##### 请求

请求报文：

* 请求方法
* 请求 URI
* 协议版本
* 可选的请求首部字段
* 内容实体

![](D:\txy\University\New_Thread\GEEK\笔记\http请求.PNG)

###### http方法

> 向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。

* GET：获取资源

  来请求访问已被 URI 识别的资源，指定的资源经服务器端==解析后==返回响应内容

* POST：传输实体主体

* PUT：传输文件

  鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。

* HEAD：获取报文__首部__

  HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。

* DELETE：删除文件

  HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。

* OPTIONS：询问支持的方法

* TRACE：追踪路径

  让 Web 服务器端将之前的请求通信环回给客户端的方法。

* CONNECT：要求用隧道协议代理

  > p40?

##### 响应

响应报文：

* 协议版本
* 状态码（表示请求成功或失败的数字代码）
* 用以解释状态码的原因短语
* 可选的响应首部字段
* 实体主体

![](D:\txy\University\New_Thread\GEEK\笔记\http响应.PNG)

HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。为了实现期望的保持状态功能，于是引入了 Cookie 技术。

> ?p35

##### 管线化

> 管线化技术出现后，不用等待响应亦可直接发送下一个请求。

##### Cookie

> HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，==无法根据之前的状态进行本次的请求处理==。

Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie 会根据从服务器端发送的响应报文内的一个叫做 __Set-Cookie __的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。（服务器记住是向谁发送的）

服务器端发现客户端发送过来的 Cookie 后，会去_检查究竟是从哪一 个客户端发来的连接请求_，然后_对比服务器上的记录_，最后得到之前 的状态信息。

### HTTP报文内的HTTP信息

##### HTTP报文

> 用于HTTP协议交互的信息。是由多行（用 CR+LF 作换行符）数据构成的字符串文本。

![](D:\txy\University\New_Thread\GEEK\笔记\http报文结构.PNG)

> p51?
>
> p53?
>
> p54!

##### 范围请求

> 要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）

执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。

##### 内容协商

> 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然 后提供给客户端最为适合的资源。
>
> 以响应资源的语言、字符集、编码方式等作为判断的基准。

* 服务器驱动协商
* 客户端驱动协商
* 透明协商

### 返回结果的HTTP状态码

![](D:\txy\University\New_Thread\GEEK\笔记\状态码.PNG)

常见状态码：

* 2XX

  * 200 OK
  * 204 No Content
  * 206 Partial Content（进行了范围请求）

* 3XX

  * 301 Moved Permanently（永久性重定向）

    > p62?

  * 302 Found（临时性重定向）

    > 请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。

  * 303 See Other

    > 由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源

    > 303 状态码和 302 Found 状态码有着相同的功能，但 明确表示客户端应当采用 GET 方法获取资源。

  * 304 Not Modified

    > 客户端发送附带条件的请求[^5]时，服务器端允许请求访问资源，但未满足条件的情况。

  * 307 Temporary Redirect（临时重定向）

  > 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次 发送
  >
  > 尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。 307 会遵照浏览器标准，不会从 POST 变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

* 4XX

  * 400 Bad Request（请求报文中存在语法错误）

    > p65??

  * 401Unauthorized

    > 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。
    >
    > 返回含有 401 的响应必须包含一个适用于被请求资源的 WWW- Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。

  * 403 Forbidden（对请求资源的访问被服务器拒绝）

  * 404 Not Found（服务器上无法找到请求的资源）

* 5XX

  * 500 Internal Server Error（服务器端在执行请求时发生了错误）

    > 也有可能是 Web 应用存在的 bug 或某些临时的故障。

  * 503 Service Unavailable（服务器暂时处于超负载或正在进行停机维护，现在无法处理请求）

[^5]:指采用 GET方法的请求报文中包含 If-Match，If-Modified- Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。

> 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。 
>
> 比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。

### 与HTTP协作的Web服务器

> 一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路 径上的中转服务器提升传输效率。

##### 通信数据转发程序

###### 代理

* 一种有转发功能的__应用程序__
* 接收由客户端发送的请求并转发给服务器
* 接收服务器返回的响应并转发给客户端

***

* 每次通过代理服务器转发请求或响应时，会追加写入 Via 首 部信息

***

* 缓存代理

  代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。

  当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

* 透明代理

  转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理 （Transparent Proxy）。

  反之，对报文内容进行加工的代理被称为__非透明代理__。

###### 网关

* 转发其他服务器通信数据的__服务器__
* 接收从客户端发送来的请求时，像自己拥有资源的源服务器[^6]一样对请求进行处理

***

* 利用网关可以由 HTTP 请求转化为其他协议通信
* 利用网关能提高通信的安全性

###### 隧道

* 在相隔甚远的客户端和服务器两者之间进行中转
* 保持双方通信连接
* __应用程序__

***

* 隧道的目的是确保客户端能与服务器进行安全的通信
* 隧道本身不会去解析 HTTP 请求

[^6]:持有资源实体的服务器被称为源服务器

##### 缓存

* 代理服务器或客户端本地磁盘内保存的__资源副本__

### HTTP首部

##### HTTP首部字段结构

`首部字段名: 字段值`

> 字段值对应单个 HTTP 首部字段可以有多个值

##### HTTP首部字段类型

###### 通用首部字段(General Header Fields)

* 请求报文和响应报文两方都会使用的首部。
* ![](D:\txy\University\New_Thread\GEEK\笔记\通用首部字段.PNG)

###### 请求首部字段(Request Header Fields)

* 从客户端向服务器端发送请求报文时使用的首部

* 补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。
* ![](D:\txy\University\New_Thread\GEEK\笔记\请求首部字段.PNG)

###### 响应首部字段(Response Header Fields)

* 从服务器端向客户端返回响应报文时使用的首部
* 补充了响应的附加内容，也会要求客户端附加额外的内容信息
* ![](D:\txy\University\New_Thread\GEEK\笔记\响应首部字段.PNG)

###### 实体首部字段(Entity Header Fields)

* 针对请求报文和响应报文的实体部分使用的首部
* 补充了资源内容更 新时间等与实体有关的信息
* ![](D:\txy\University\New_Thread\GEEK\笔记\实体首部字段.PNG)

###### 非HTTP/1.1首部字段

* End-to-end
  * 会转发给对应的最终接收目标
  * 保存在由缓存生成的响应中
  * 必须被转发
* Hop-to-hop
  * 只对单次转发有效
  * 通过缓存或代理不再转发
  * 需提供Connection首部字段

###### HTTP/1.1通用首部字段

* Cache-Control

  * 操作缓存

  * 指令的参数是可选的，多个指令之间通过“,”分隔

  * 用于请求及响应时

    ![请求](D:\txy\University\New_Thread\GEEK\笔记\缓存请求指令.PNG)

    ![响应](D:\txy\University\New_Thread\GEEK\笔记\缓存响应指令.PNG)

    > p87-88?
    >
    > p89?

* Connection

  * __控制__不再转发给代理的__首部字段__

    `Connection: 不再转发的首部字段名`

    * 即Hop-by-hop首部

  * 管理持久连接

    `Connection: Close`

    * HTTP/1.1默认持久连接
    * 客户端会在持久连接上连续发送请求
    * 当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close

    `Connection: Keep-Alive`

    * HTTP/1.1 之前的 HTTP 版本的默认非持久连接
    * 在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive

* Date

  > 表明创建 HTTP 报文的日期和时间。

* Pragma

  > Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。
  >
  > 该首部字段属于通用首部字段，但只用在客户端发送的请求中。要求所有的中间服务器不返回缓存的资源。

* Trailer

  > 会事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时。

* Transfer-Encoding

  > 规定传输报文主体时采用的编码方式。
  >
  > * 仅对分块传输编码有效

* Upgrade

  > 检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。
  >
  > p97?

* Via

  > 追踪客户端与服务器之间的请求和响应报文 的传输路径。
  >
  > 可避免请求回环的发生。必须在经过代理时附加该首部字段内容。

* Warning

  * `Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])`

    ![](D:\txy\University\New_Thread\GEEK\笔记\http警告码.PNG)

###### 请求首部字段

* Accept

  `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0`

  * type/subtype

  >使用` q= `来额外表示权重值 1，用分号`;`进行分隔。p100?
  >
  >权重值 q 的范围是 0~1（可精确到小数点 后 3 位），且 1 为最大值。
  >
  >默认权重为 q=1.0。

* Accept-Charset

  * 通知服务器用户代理支持的__字符集__及字符集的相对优先顺序
  * 可一次性指定多种字符集
  * 可用权重 q 值来表示相对优先级

* Accept-Encoding 

  * 告知服务器用户代理支持的__内容编码__及内容编码的优先级顺序
  * 可一次性指定多种内容编码
  * 采用权重 q 值来表示相对优先级,
  * 可使用星号（*）作为通配符，指定任意的编码格式。

*  Accept-Language

  * 服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级
  * 可一次指定多种自然语言集
  * 按权重值 q 来表示相对优先级

* Authorization

  * 告知服务器，用户代理的认证信息（证书值）
  * 通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中
  * 共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异

* Expect

  * 告知服务器，期望出现的某种特定行为
  * 因服务器无法理解客户端的期望作出回应而发生错误时，会返回 状态码 417 Expectation Failed
  *  客户端可以利用该首部字段，写明所期望的扩展
  *  HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意）
  *  等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100- continue

* From

  * 告知服务器使用用户代理的用户的电子邮件地址
  * 通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式
  * 使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）

* Host 

  * 告知服务器，请求的资源所处的互联网主机名和端口号
  * Host 首部字段在 HTTP/1.1 规范内是唯一一个==必须被包含在请求内==的首部字段
  *  首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联
  *  请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决
  * 相同的 IP 地址下部署运行着多个域名，服务器就会无法理解究竟是哪个域名对应的请求，就需要使用首部字段 Host 来明确指出请求的主机名
  * 若服务器未设定主机名，直接发送一个空值即可

* 形如 If-xxx 

  > 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。

* Proxy-Authorization

  > 认证行为发生在客户端与代理之间

* Range 

  * 告知服务器资源的指定范围

* Referer 

  * 告知服务器请求的原始资源的 URI

    > 当直接在浏览器 的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段

* TE 

  * 告知服务器客户端能够处理响应的__传输编码方式__及相对优先级

  *  首部字段TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式

    ` TE: trailers`

* User-Agent 

  * 用于传达浏览器的种类 

    `User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1 `

  * 将创建请求的浏览器和用户代理名称等信息传达给服务器

  * 如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。

###### 响应首部字段

* Accept-Ranges

  * 来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。 
  * bytes——可处理范围请求
  * none——不可处理范围请求

* Age 

  * 告知客户端，源服务器在多久前创建了响应
  * 字段值的单位为秒

  > 若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应__再次发起认证到认证完成__的时间值。
  >
  > 代理创建响应时==必须加上首部字段 Age==。

* ETag

  * 告知客户端实体标识

  * 是一种可将资源以__字符串__形式做__唯一性标识__的方式

  * 服务器会为每份资源分配对应的 ETag 值

  * 资源被缓存时，就会被分配唯一性标识；当资源更新时，ETag 值也需要更新

  * 生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配

  * __强 ETag 值，弱 ETag 值__

    > 强 ETag 值
    >
    > 不论实体发生多么细微的变化都会改变其值。 
    >
    >  弱 ETag 值
    >
    > 只用于提示资源==是否相同==。
    >
    > 只有资源发生了__根本改变__，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。

* Location

  可以将响应接收方引导至某个与请求 URI 位置不同的资源。

  基本上，该字段会配合`3xx ：Redirection`的响应，提供重定向的 URI。

* Proxy-Authenticate

  * 把由代理服务器所要求的认证信息发送给客户端

  * 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在__客户端与代理之间进行__的

    > 客户端与服务器之间 进行认证时，首部字段 WWW-Authorization 有着相同的作用

* Retry-After

  * 告知客户端应该在多久之后再次发送请求
  * 主要配合状态码 `503 Service Unavailable`响应，或 `3xx Redirect` 响应一起使用
  * 字段值可以指定为具体的日期时间，也可以是创建响应后的秒数

* Server 

  * 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息
  * 不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项

* Vary

  * 对缓存进行控制：源服务器会向代理服务器传达关 于本地缓存使用方法的命令

* WWW-Authenticate

  * 用于 HTTP 访问认证
  * 告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）
  * 状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate

###### 实体首部字段

* Allow 

  * 通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法
  * 当服务器接收到不支持的 HTTP 方法时，会以状态码`405 Method Not Allowed`作为响应返回；与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回

* Content-Encoding

  * 告知客户端服务器对实体的主体部分选用的内容编码方式

    > 内容编码是指在不丢失实体信息的前提下所进行的压缩。

* Content-Language

* Content-Length

  * 单位：字节
  * 对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段

* Content-Location

  * 报文主体返回资源对应的 URI

    > p125?

* 

